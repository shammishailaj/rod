// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// TargetActivateTarget Activates (focuses) the target.
type TargetActivateTarget struct {
	// TargetID ...
	TargetID *TargetTargetID `json:"targetId"`
}

// TargetActivateTargetResult type
type TargetActivateTargetResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetActivateTarget) Call(c *Call) (*TargetActivateTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetActivateTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetActivateTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetAttachToTarget Attaches to the target with given id.
type TargetAttachToTarget struct {
	// TargetID ...
	TargetID *TargetTargetID `json:"targetId"`

	// Flatten Enables "flat" access to the session via specifying sessionId attribute in the commands.
	// We plan to make this the default, deprecate non-flattened mode,
	// and eventually retire it. See crbug.com/991325.
	Flatten bool `json:"flatten,omitempty"`
}

// TargetAttachToTargetResult type
type TargetAttachToTargetResult struct {
	// SessionID Id assigned to the session.
	SessionID *TargetSessionID `json:"sessionId"`
}

// Call of the command, sessionID is optional.
func (m TargetAttachToTarget) Call(c *Call) (*TargetAttachToTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetAttachToTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetAttachToTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetAttachToBrowserTarget (experimental) Attaches to the browser target, only uses flat sessionId mode.
type TargetAttachToBrowserTarget struct {
}

// TargetAttachToBrowserTargetResult type
type TargetAttachToBrowserTargetResult struct {
	// SessionID Id assigned to the session.
	SessionID *TargetSessionID `json:"sessionId"`
}

// Call of the command, sessionID is optional.
func (m TargetAttachToBrowserTarget) Call(c *Call) (*TargetAttachToBrowserTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetAttachToBrowserTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetAttachToBrowserTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetCloseTarget Closes the target. If the target is a page that gets closed too.
type TargetCloseTarget struct {
	// TargetID ...
	TargetID *TargetTargetID `json:"targetId"`
}

// TargetCloseTargetResult type
type TargetCloseTargetResult struct {
	// Success ...
	Success bool `json:"success"`
}

// Call of the command, sessionID is optional.
func (m TargetCloseTarget) Call(c *Call) (*TargetCloseTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetCloseTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetCloseTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetExposeDevToolsProtocol (experimental) Inject object to the target's main frame that provides a communication
// channel with browser target.
//
// Injected object will be available as `window[bindingName]`.
//
// The object has the follwing API:
// - `binding.send(json)` - a method to send messages over the remote debugging protocol
// - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
type TargetExposeDevToolsProtocol struct {
	// TargetID ...
	TargetID *TargetTargetID `json:"targetId"`

	// BindingName Binding name, 'cdp' if not specified.
	BindingName string `json:"bindingName,omitempty"`
}

// TargetExposeDevToolsProtocolResult type
type TargetExposeDevToolsProtocolResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetExposeDevToolsProtocol) Call(c *Call) (*TargetExposeDevToolsProtocolResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetExposeDevToolsProtocol", m)
	if err != nil {
		return nil, err
	}

	var res TargetExposeDevToolsProtocolResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetCreateBrowserContext (experimental) Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
// one.
type TargetCreateBrowserContext struct {
}

// TargetCreateBrowserContextResult type
type TargetCreateBrowserContextResult struct {
	// BrowserContextID The id of the context created.
	BrowserContextID *BrowserBrowserContextID `json:"browserContextId"`
}

// Call of the command, sessionID is optional.
func (m TargetCreateBrowserContext) Call(c *Call) (*TargetCreateBrowserContextResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetCreateBrowserContext", m)
	if err != nil {
		return nil, err
	}

	var res TargetCreateBrowserContextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetGetBrowserContexts (experimental) Returns all browser contexts created with `Target.createBrowserContext` method.
type TargetGetBrowserContexts struct {
}

// TargetGetBrowserContextsResult type
type TargetGetBrowserContextsResult struct {
	// BrowserContextIds An array of browser context ids.
	BrowserContextIds []*BrowserBrowserContextID `json:"browserContextIds"`
}

// Call of the command, sessionID is optional.
func (m TargetGetBrowserContexts) Call(c *Call) (*TargetGetBrowserContextsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetGetBrowserContexts", m)
	if err != nil {
		return nil, err
	}

	var res TargetGetBrowserContextsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetCreateTarget Creates a new page.
type TargetCreateTarget struct {
	// URL The initial URL the page will be navigated to.
	URL string `json:"url"`

	// Width Frame width in DIP (headless chrome only).
	Width int64 `json:"width,omitempty"`

	// Height Frame height in DIP (headless chrome only).
	Height int64 `json:"height,omitempty"`

	// BrowserContextID The browser context to create the page in.
	BrowserContextID *BrowserBrowserContextID `json:"browserContextId,omitempty"`

	// EnableBeginFrameControl (experimental) Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
	// not supported on MacOS yet, false by default).
	EnableBeginFrameControl bool `json:"enableBeginFrameControl,omitempty"`

	// NewWindow Whether to create a new Window or Tab (chrome-only, false by default).
	NewWindow bool `json:"newWindow,omitempty"`

	// Background Whether to create the target in background or foreground (chrome-only,
	// false by default).
	Background bool `json:"background,omitempty"`
}

// TargetCreateTargetResult type
type TargetCreateTargetResult struct {
	// TargetID The id of the page opened.
	TargetID *TargetTargetID `json:"targetId"`
}

// Call of the command, sessionID is optional.
func (m TargetCreateTarget) Call(c *Call) (*TargetCreateTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetCreateTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetCreateTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetDetachFromTarget Detaches session with given id.
type TargetDetachFromTarget struct {
	// SessionID Session to detach.
	SessionID *TargetSessionID `json:"sessionId,omitempty"`

	// TargetID (deprecated) Deprecated.
	TargetID *TargetTargetID `json:"targetId,omitempty"`
}

// TargetDetachFromTargetResult type
type TargetDetachFromTargetResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetDetachFromTarget) Call(c *Call) (*TargetDetachFromTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetDetachFromTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetDetachFromTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetDisposeBrowserContext (experimental) Deletes a BrowserContext. All the belonging pages will be closed without calling their
// beforeunload hooks.
type TargetDisposeBrowserContext struct {
	// BrowserContextID ...
	BrowserContextID *BrowserBrowserContextID `json:"browserContextId"`
}

// TargetDisposeBrowserContextResult type
type TargetDisposeBrowserContextResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetDisposeBrowserContext) Call(c *Call) (*TargetDisposeBrowserContextResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetDisposeBrowserContext", m)
	if err != nil {
		return nil, err
	}

	var res TargetDisposeBrowserContextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetGetTargetInfo (experimental) Returns information about a target.
type TargetGetTargetInfo struct {
	// TargetID ...
	TargetID *TargetTargetID `json:"targetId,omitempty"`
}

// TargetGetTargetInfoResult type
type TargetGetTargetInfoResult struct {
	// TargetInfo ...
	TargetInfo *TargetTargetInfo `json:"targetInfo"`
}

// Call of the command, sessionID is optional.
func (m TargetGetTargetInfo) Call(c *Call) (*TargetGetTargetInfoResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetGetTargetInfo", m)
	if err != nil {
		return nil, err
	}

	var res TargetGetTargetInfoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetGetTargets Retrieves a list of available targets.
type TargetGetTargets struct {
}

// TargetGetTargetsResult type
type TargetGetTargetsResult struct {
	// TargetInfos The list of targets.
	TargetInfos []*TargetTargetInfo `json:"targetInfos"`
}

// Call of the command, sessionID is optional.
func (m TargetGetTargets) Call(c *Call) (*TargetGetTargetsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetGetTargets", m)
	if err != nil {
		return nil, err
	}

	var res TargetGetTargetsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetSendMessageToTarget (deprecated) Sends protocol message over session with given id.
// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
// and crbug.com/991325.
type TargetSendMessageToTarget struct {
	// Message ...
	Message string `json:"message"`

	// SessionID Identifier of the session.
	SessionID *TargetSessionID `json:"sessionId,omitempty"`

	// TargetID (deprecated) Deprecated.
	TargetID *TargetTargetID `json:"targetId,omitempty"`
}

// TargetSendMessageToTargetResult type
type TargetSendMessageToTargetResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetSendMessageToTarget) Call(c *Call) (*TargetSendMessageToTargetResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetSendMessageToTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetSendMessageToTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetSetAutoAttach (experimental) Controls whether to automatically attach to new targets which are considered to be related to
// this one. When turned on, attaches to all existing related targets as well. When turned off,
// automatically detaches from all currently attached targets.
type TargetSetAutoAttach struct {
	// AutoAttach Whether to auto-attach to related targets.
	AutoAttach bool `json:"autoAttach"`

	// WaitForDebuggerOnStart Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
	// to run paused targets.
	WaitForDebuggerOnStart bool `json:"waitForDebuggerOnStart"`

	// Flatten Enables "flat" access to the session via specifying sessionId attribute in the commands.
	// We plan to make this the default, deprecate non-flattened mode,
	// and eventually retire it. See crbug.com/991325.
	Flatten bool `json:"flatten,omitempty"`

	// WindowOpen (experimental) Auto-attach to the targets created via window.open from current target.
	WindowOpen bool `json:"windowOpen,omitempty"`
}

// TargetSetAutoAttachResult type
type TargetSetAutoAttachResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetSetAutoAttach) Call(c *Call) (*TargetSetAutoAttachResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetSetAutoAttach", m)
	if err != nil {
		return nil, err
	}

	var res TargetSetAutoAttachResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetSetDiscoverTargets Controls whether to discover available targets and notify via
// `targetCreated/targetInfoChanged/targetDestroyed` events.
type TargetSetDiscoverTargets struct {
	// Discover Whether to discover available targets.
	Discover bool `json:"discover"`
}

// TargetSetDiscoverTargetsResult type
type TargetSetDiscoverTargetsResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetSetDiscoverTargets) Call(c *Call) (*TargetSetDiscoverTargetsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetSetDiscoverTargets", m)
	if err != nil {
		return nil, err
	}

	var res TargetSetDiscoverTargetsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetSetRemoteLocations (experimental) Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
// `true`.
type TargetSetRemoteLocations struct {
	// Locations List of remote locations.
	Locations []*TargetRemoteLocation `json:"locations"`
}

// TargetSetRemoteLocationsResult type
type TargetSetRemoteLocationsResult struct {
}

// Call of the command, sessionID is optional.
func (m TargetSetRemoteLocations) Call(c *Call) (*TargetSetRemoteLocationsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "TargetSetRemoteLocations", m)
	if err != nil {
		return nil, err
	}

	var res TargetSetRemoteLocationsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
