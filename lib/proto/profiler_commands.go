// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// ProfilerDisable ...
type ProfilerDisable struct {
}

// ProfilerDisableResult type
type ProfilerDisableResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerDisable) Call(c *Call) (*ProfilerDisableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerDisable", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerDisableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerEnable ...
type ProfilerEnable struct {
}

// ProfilerEnableResult type
type ProfilerEnableResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerEnable) Call(c *Call) (*ProfilerEnableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerEnable", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerEnableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerGetBestEffortCoverage Collect coverage data for the current isolate. The coverage data may be incomplete due to
// garbage collection.
type ProfilerGetBestEffortCoverage struct {
}

// ProfilerGetBestEffortCoverageResult type
type ProfilerGetBestEffortCoverageResult struct {
	// Result Coverage data for the current isolate.
	Result []*ProfilerScriptCoverage `json:"result"`
}

// Call of the command, sessionID is optional.
func (m ProfilerGetBestEffortCoverage) Call(c *Call) (*ProfilerGetBestEffortCoverageResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerGetBestEffortCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerGetBestEffortCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerSetSamplingInterval Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
type ProfilerSetSamplingInterval struct {
	// Interval New sampling interval in microseconds.
	Interval int64 `json:"interval"`
}

// ProfilerSetSamplingIntervalResult type
type ProfilerSetSamplingIntervalResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerSetSamplingInterval) Call(c *Call) (*ProfilerSetSamplingIntervalResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerSetSamplingInterval", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerSetSamplingIntervalResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStart ...
type ProfilerStart struct {
}

// ProfilerStartResult type
type ProfilerStartResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStart) Call(c *Call) (*ProfilerStartResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerStart", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStartResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStartPreciseCoverage Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
// coverage may be incomplete. Enabling prevents running optimized code and resets execution
// counters.
type ProfilerStartPreciseCoverage struct {
	// CallCount Collect accurate call counts beyond simple 'covered' or 'not covered'.
	CallCount bool `json:"callCount,omitempty"`

	// Detailed Collect block-based coverage.
	Detailed bool `json:"detailed,omitempty"`
}

// ProfilerStartPreciseCoverageResult type
type ProfilerStartPreciseCoverageResult struct {
	// Timestamp Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
	Timestamp float64 `json:"timestamp"`
}

// Call of the command, sessionID is optional.
func (m ProfilerStartPreciseCoverage) Call(c *Call) (*ProfilerStartPreciseCoverageResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerStartPreciseCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStartPreciseCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStartTypeProfile (experimental) Enable type profile.
type ProfilerStartTypeProfile struct {
}

// ProfilerStartTypeProfileResult type
type ProfilerStartTypeProfileResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStartTypeProfile) Call(c *Call) (*ProfilerStartTypeProfileResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerStartTypeProfile", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStartTypeProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStop ...
type ProfilerStop struct {
}

// ProfilerStopResult type
type ProfilerStopResult struct {
	// Profile Recorded profile.
	Profile *ProfilerProfile `json:"profile"`
}

// Call of the command, sessionID is optional.
func (m ProfilerStop) Call(c *Call) (*ProfilerStopResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerStop", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStopResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStopPreciseCoverage Disable precise code coverage. Disabling releases unnecessary execution count records and allows
// executing optimized code.
type ProfilerStopPreciseCoverage struct {
}

// ProfilerStopPreciseCoverageResult type
type ProfilerStopPreciseCoverageResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStopPreciseCoverage) Call(c *Call) (*ProfilerStopPreciseCoverageResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerStopPreciseCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStopPreciseCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStopTypeProfile (experimental) Disable type profile. Disabling releases type profile data collected so far.
type ProfilerStopTypeProfile struct {
}

// ProfilerStopTypeProfileResult type
type ProfilerStopTypeProfileResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStopTypeProfile) Call(c *Call) (*ProfilerStopTypeProfileResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerStopTypeProfile", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStopTypeProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerTakePreciseCoverage Collect coverage data for the current isolate, and resets execution counters. Precise code
// coverage needs to have started.
type ProfilerTakePreciseCoverage struct {
}

// ProfilerTakePreciseCoverageResult type
type ProfilerTakePreciseCoverageResult struct {
	// Result Coverage data for the current isolate.
	Result []*ProfilerScriptCoverage `json:"result"`

	// Timestamp Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
	Timestamp float64 `json:"timestamp"`
}

// Call of the command, sessionID is optional.
func (m ProfilerTakePreciseCoverage) Call(c *Call) (*ProfilerTakePreciseCoverageResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerTakePreciseCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerTakePreciseCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerTakeTypeProfile (experimental) Collect type profile.
type ProfilerTakeTypeProfile struct {
}

// ProfilerTakeTypeProfileResult type
type ProfilerTakeTypeProfileResult struct {
	// Result Type profile for all scripts since startTypeProfile() was turned on.
	Result []*ProfilerScriptTypeProfile `json:"result"`
}

// Call of the command, sessionID is optional.
func (m ProfilerTakeTypeProfile) Call(c *Call) (*ProfilerTakeTypeProfileResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerTakeTypeProfile", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerTakeTypeProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerEnableRuntimeCallStats (experimental) Enable run time call stats collection.
type ProfilerEnableRuntimeCallStats struct {
}

// ProfilerEnableRuntimeCallStatsResult type
type ProfilerEnableRuntimeCallStatsResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerEnableRuntimeCallStats) Call(c *Call) (*ProfilerEnableRuntimeCallStatsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerEnableRuntimeCallStats", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerEnableRuntimeCallStatsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerDisableRuntimeCallStats (experimental) Disable run time call stats collection.
type ProfilerDisableRuntimeCallStats struct {
}

// ProfilerDisableRuntimeCallStatsResult type
type ProfilerDisableRuntimeCallStatsResult struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerDisableRuntimeCallStats) Call(c *Call) (*ProfilerDisableRuntimeCallStatsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerDisableRuntimeCallStats", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerDisableRuntimeCallStatsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerGetRuntimeCallStats (experimental) Retrieve run time call stats.
type ProfilerGetRuntimeCallStats struct {
}

// ProfilerGetRuntimeCallStatsResult type
type ProfilerGetRuntimeCallStatsResult struct {
	// Result Collected counter information.
	Result []*ProfilerCounterInfo `json:"result"`
}

// Call of the command, sessionID is optional.
func (m ProfilerGetRuntimeCallStats) Call(c *Call) (*ProfilerGetRuntimeCallStatsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "ProfilerGetRuntimeCallStats", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerGetRuntimeCallStatsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
