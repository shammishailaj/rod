// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// FetchDisable Disables the fetch domain.
type FetchDisable struct {
}

// FetchDisableResult type
type FetchDisableResult struct {
}

// Call of the command, sessionID is optional.
func (m FetchDisable) Call(c *Call) (*FetchDisableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchDisable", m)
	if err != nil {
		return nil, err
	}

	var res FetchDisableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchEnable Enables issuing of requestPaused events. A request will be paused until client
// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
type FetchEnable struct {
	// Patterns If specified, only requests matching any of these patterns will produce
	// fetchRequested event and will be paused until clients response. If not set,
	// all requests will be affected.
	Patterns []*FetchRequestPattern `json:"patterns,omitempty"`

	// HandleAuthRequests If true, authRequired events will be issued and requests will be paused
	// expecting a call to continueWithAuth.
	HandleAuthRequests bool `json:"handleAuthRequests,omitempty"`
}

// FetchEnableResult type
type FetchEnableResult struct {
}

// Call of the command, sessionID is optional.
func (m FetchEnable) Call(c *Call) (*FetchEnableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchEnable", m)
	if err != nil {
		return nil, err
	}

	var res FetchEnableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchFailRequest Causes the request to fail with specified reason.
type FetchFailRequest struct {
	// RequestID An id the client received in requestPaused event.
	RequestID *FetchRequestID `json:"requestId"`

	// ErrorReason Causes the request to fail with the given reason.
	ErrorReason *NetworkErrorReason `json:"errorReason"`
}

// FetchFailRequestResult type
type FetchFailRequestResult struct {
}

// Call of the command, sessionID is optional.
func (m FetchFailRequest) Call(c *Call) (*FetchFailRequestResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchFailRequest", m)
	if err != nil {
		return nil, err
	}

	var res FetchFailRequestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchFulfillRequest Provides response to the request.
type FetchFulfillRequest struct {
	// RequestID An id the client received in requestPaused event.
	RequestID *FetchRequestID `json:"requestId"`

	// ResponseCode An HTTP response code.
	ResponseCode int64 `json:"responseCode"`

	// ResponseHeaders Response headers.
	ResponseHeaders []*FetchHeaderEntry `json:"responseHeaders,omitempty"`

	// BinaryResponseHeaders Alternative way of specifying response headers as a \0-separated
	// series of name: value pairs. Prefer the above method unless you
	// need to represent some non-UTF8 values that can't be transmitted
	// over the protocol as text.
	BinaryResponseHeaders []byte `json:"binaryResponseHeaders,omitempty"`

	// Body A response body.
	Body []byte `json:"body,omitempty"`

	// ResponsePhrase A textual representation of responseCode.
	// If absent, a standard phrase matching responseCode is used.
	ResponsePhrase string `json:"responsePhrase,omitempty"`
}

// FetchFulfillRequestResult type
type FetchFulfillRequestResult struct {
}

// Call of the command, sessionID is optional.
func (m FetchFulfillRequest) Call(c *Call) (*FetchFulfillRequestResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchFulfillRequest", m)
	if err != nil {
		return nil, err
	}

	var res FetchFulfillRequestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchContinueRequest Continues the request, optionally modifying some of its parameters.
type FetchContinueRequest struct {
	// RequestID An id the client received in requestPaused event.
	RequestID *FetchRequestID `json:"requestId"`

	// URL If set, the request url will be modified in a way that's not observable by page.
	URL string `json:"url,omitempty"`

	// Method If set, the request method is overridden.
	Method string `json:"method,omitempty"`

	// PostData If set, overrides the post data in the request.
	PostData string `json:"postData,omitempty"`

	// Headers If set, overrides the request headrts.
	Headers []*FetchHeaderEntry `json:"headers,omitempty"`
}

// FetchContinueRequestResult type
type FetchContinueRequestResult struct {
}

// Call of the command, sessionID is optional.
func (m FetchContinueRequest) Call(c *Call) (*FetchContinueRequestResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchContinueRequest", m)
	if err != nil {
		return nil, err
	}

	var res FetchContinueRequestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchContinueWithAuth Continues a request supplying authChallengeResponse following authRequired event.
type FetchContinueWithAuth struct {
	// RequestID An id the client received in authRequired event.
	RequestID *FetchRequestID `json:"requestId"`

	// AuthChallengeResponse Response to  with an authChallenge.
	AuthChallengeResponse *FetchAuthChallengeResponse `json:"authChallengeResponse"`
}

// FetchContinueWithAuthResult type
type FetchContinueWithAuthResult struct {
}

// Call of the command, sessionID is optional.
func (m FetchContinueWithAuth) Call(c *Call) (*FetchContinueWithAuthResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchContinueWithAuth", m)
	if err != nil {
		return nil, err
	}

	var res FetchContinueWithAuthResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchGetResponseBody Causes the body of the response to be received from the server and
// returned as a single string. May only be issued for a request that
// is paused in the Response stage and is mutually exclusive with
// takeResponseBodyForInterceptionAsStream. Calling other methods that
// affect the request or disabling fetch domain before body is received
// results in an undefined behavior.
type FetchGetResponseBody struct {
	// RequestID Identifier for the intercepted request to get body for.
	RequestID *FetchRequestID `json:"requestId"`
}

// FetchGetResponseBodyResult type
type FetchGetResponseBodyResult struct {
	// Body Response body.
	Body string `json:"body"`

	// Base64Encoded True, if content was sent as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// Call of the command, sessionID is optional.
func (m FetchGetResponseBody) Call(c *Call) (*FetchGetResponseBodyResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchGetResponseBody", m)
	if err != nil {
		return nil, err
	}

	var res FetchGetResponseBodyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchTakeResponseBodyAsStream Returns a handle to the stream representing the response body.
// The request must be paused in the HeadersReceived stage.
// Note that after this command the request can't be continued
// as is -- client either needs to cancel it or to provide the
// response body.
// The stream only supports sequential read, IO.read will fail if the position
// is specified.
// This method is mutually exclusive with getResponseBody.
// Calling other methods that affect the request or disabling fetch
// domain before body is received results in an undefined behavior.
type FetchTakeResponseBodyAsStream struct {
	// RequestID ...
	RequestID *FetchRequestID `json:"requestId"`
}

// FetchTakeResponseBodyAsStreamResult type
type FetchTakeResponseBodyAsStreamResult struct {
	// Stream ...
	Stream *IOStreamHandle `json:"stream"`
}

// Call of the command, sessionID is optional.
func (m FetchTakeResponseBodyAsStream) Call(c *Call) (*FetchTakeResponseBodyAsStreamResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "FetchTakeResponseBodyAsStream", m)
	if err != nil {
		return nil, err
	}

	var res FetchTakeResponseBodyAsStreamResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
