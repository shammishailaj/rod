package main

import (
	"fmt"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/tidwall/gjson"
	"github.com/ysmood/kit"
	"github.com/ysmood/rod/lib/launcher"
)

var slash = filepath.FromSlash

const genPrefix = "// This file is generated by \"./lib/proto/cmd/gen\"\n\n"

var tests = ""

func main() {
	schema := getSchema()

	version(*schema)

	for _, domain := range schema.Get("domains").Array() {
		types(domain)
		commands(domain)
		events(domain)
	}

	code := kit.S(genPrefix+`package proto_test

	import (
		"testing"
		"context"
		"github.com/ysmood/rod/lib/proto"
		"github.com/stretchr/testify/assert"
	)

	{{.code}}
	`, "code", tests)

	kit.E(kit.OutputFile("lib/proto/basic_test.go", code, nil))

	kit.Exec("gofmt", "-s", "-w", "./lib/proto").MustDo()
	kit.Exec("goimports", "-w", "./lib/proto").MustDo()
}

func version(schema gjson.Result) {
	ver := schema.Get("version")

	code := kit.S(genPrefix+`package proto

	// Version of the cdp protocol
	const Version = "{{.ver}}"
	`, "ver", ver.Get("major").String()+"."+ver.Get("minor").String())

	kit.E(kit.OutputFile("lib/proto/version.go", code, nil))
}

func types(domainSchema gjson.Result) {
	domain := domainSchema.Get("domain").String()
	code := ""

	for _, schema := range domainSchema.Get("types").Array() {
		name := domain + schema.Get("id").String()
		code += comment(name, schema)
		code += "type " + convertType(domain, name, schema) + "\n"

		if schema.Get("enum").Exists() {
			code += convertEnum(name, schema)
		}
	}

	tpl := genPrefix + `package proto

	{{.code}}
	`
	code = kit.S(tpl, "code", code)

	file := slash("lib/proto/" + snake(domain) + "_types.go")
	kit.E(kit.OutputFile(file, code, nil))
}

func commands(domainSchema gjson.Result) {
	domain := domainSchema.Get("domain").String()
	code := ""

	for _, cmd := range domainSchema.Get("commands").Array() {
		name := domain + symbol(cmd.Get("name").String())
		enumCode := ""

		paramsCode := comment(name, cmd)
		paramsCode += "type " + name + " struct {\n"
		for _, param := range cmd.Get("parameters").Array() {
			paramName := param.Get("name").String()

			paramsCode += comment(paramName, param)

			if param.Get("enum").Exists() {
				enumName := domain + name + symbol(paramName)
				enumCode += "// " + enumName + " Enum of possible values\n"
				enumCode += "type " + enumName + " string\n"
				enumCode += convertEnum(enumName, param)
				paramsCode += symbol(paramName) + " " + enumName
			} else {
				paramsCode += convertType(domain, paramName, param)
			}

			paramsCode += jsonTag(paramName, param) + "\n\n"
		}
		paramsCode += "}\n\n"

		code += enumCode + paramsCode

		code += "// " + name + "Result type\n"
		code += "type " + name + "Result struct {\n"
		for _, param := range cmd.Get("returns").Array() {
			paramName := param.Get("name").String()
			code += comment(paramName, param)
			code += convertType(domain, paramName, param)
			code += jsonTag(paramName, param) + "\n\n"
		}
		code += "}\n\n"

		params := []interface{}{"name", name, "method", domain + "." + cmd.Get("name").String()}

		code += kit.S(`
		// Call of the command, sessionID is optional.
		func (m {{.name}}) Call(c *Call) (*{{.name}}Result, error) {
			bin, err := c.Client.Call(c.Context, c.SessionID, "{{.name}}", m)
			if err != nil {
				return nil, err
			}

			var res {{.name}}Result
			err = json.Unmarshal(bin, &res)
			if err != nil {
				return nil, err
			}
	
			return &res, nil
		}
		`, params...)

		tests += kit.S(`
		func Test{{.name}}(t *testing.T) {
			ctx := context.Background()
			c := &Client{}
			_, err := proto.{{.name}}{}.Call(&proto.Call{ctx, c, ""})
			assert.Nil(t, err)
			
			c = &Client{err: errors.New("err")}
			_, err = proto.{{.name}}{}.Call(&proto.Call{ctx, c, ""})
			assert.Error(t, err)

			c = &Client{ret: "err"}
			_, err = proto.{{.name}}{}.Call(&proto.Call{ctx, c, ""})
			assert.Error(t, err)
		}
		`, params...)

	}

	tpl := genPrefix + `package proto

	import (
		"context"
		"encoding/json"
	)

	{{.code}}
	`
	code = kit.S(tpl, "code", code)

	file := slash("lib/proto/" + snake(domain) + "_commands.go")
	kit.E(kit.OutputFile(file, code, nil))
}

func events(domainSchema gjson.Result) {
	domain := domainSchema.Get("domain").String()
	code := ""

	for _, schema := range domainSchema.Get("events").Array() {
		name := domain + symbol(schema.Get("name").String())
		code += comment(name, schema)

		code += "type " + name + " struct {\n"
		for _, param := range schema.Get("parameters").Array() {
			paramName := param.Get("name").String()
			code += comment(paramName, param)
			code += convertType(domain, paramName, param)
			code += jsonTag(paramName, param) + "\n\n"
		}
		code += "}\n\n"

		code += kit.S(`
		// MethodName interface
		func (evt {{.name}}) MethodName() string {
			return "{{.domain}}.{{.event}}"
		}

		// Load json
		func (evt {{.name}}) Load(b []byte) *{{.name}} {
			E(json.Unmarshal(b, &evt))
			return &evt
		}
		`, "name", name, "domain", domain, "event", schema.Get("name").String())

		tests += kit.S(`
		func Test{{.name}}(t *testing.T) {
			e := proto.{{.name}}{}
			e.MethodName()
			e.Load([]byte("null"))
		}
		`, "name", name)
	}

	tpl := genPrefix + `package proto

	import "encoding/json"

	{{.code}}
	`
	code = kit.S(tpl, "code", code)

	file := slash("lib/proto/" + snake(domain) + "_events.go")
	kit.E(kit.OutputFile(file, code, nil))
}

func convertType(domain, name string, t gjson.Result) string {
	name = symbol(name)

	switch t.Get("type").String() {
	case "any":
		return name + " interface{}"

	case "string":
		return name + " string"

	case "number":
		return name + " float64"

	case "integer":
		return name + " int64"

	case "boolean":
		return name + " bool"

	case "binary":
		return name + " []byte"

	case "array":
		if t.Get("items.$ref").Exists() {
			return name + " []" + typeName(domain, t.Get("items.$ref").String())
		}
		return name + " []" + convertType(domain, "", t.Get("items"))

	case "object":
		if !t.Get("properties").Exists() {
			return name + " map[string]interface{}"
		}

		code := symbol(name) + " struct {\n"

		for _, prop := range t.Get("properties").Array() {
			n := prop.Get("name").String()

			code += comment(n, prop)
			code += convertType(domain, n, prop)
			code += jsonTag(n, prop) + "\n\n"
		}

		return code + "}\n"

	default:
		return name + " " + typeName(domain, t.Get("$ref").String())
	}
}

func getSchema() *gjson.Result {
	l := launcher.New()
	url := l.Launch()
	return kit.JSON(kit.Req(url + "/json/protocol").MustString())
}

func jsonTag(n string, prop gjson.Result) string {
	jsonTagValue := n
	if prop.Get("optional").Bool() {
		jsonTagValue += ",omitempty"
	}
	return fmt.Sprintf("`json:\"%s\"`", jsonTagValue)
}

func comment(name string, schema gjson.Result) string {
	comment := schema.Get("description").String()
	experimental := schema.Get("experimental").Bool()
	deprecated := schema.Get("deprecated").Bool()

	if comment == "" {
		comment = "..."
	}

	if experimental {
		comment = "(experimental) " + comment
	}
	if deprecated {
		comment = "(deprecated) " + comment
	}

	comment = symbol(name) + " " + comment

	return regexp.MustCompile(`(?m)^`).ReplaceAllString(comment, "// ") + "\n"
}

// make sure golint works fine
func symbol(n string) string {
	if n == "" {
		return ""
	}

	dashed := regexp.MustCompile(`[-_]`).Split(n, -1)
	if len(dashed) > 1 {
		converted := []string{}
		for _, part := range dashed {
			converted = append(converted, strings.ToUpper(part[:1])+part[1:])
		}
		n = strings.Join(converted, "")
	}

	n = strings.ToUpper(n[:1]) + n[1:]

	n = replaceLower(n, "Id")
	n = replaceLower(n, "Css")
	n = replaceLower(n, "Url")
	n = replaceLower(n, "Uuid")
	n = replaceLower(n, "Xml")
	n = replaceLower(n, "Http")
	n = replaceLower(n, "Dns")
	n = replaceLower(n, "Cpu")
	n = replaceLower(n, "Mime")
	n = replaceLower(n, "Json")
	n = replaceLower(n, "Html")
	n = replaceLower(n, "Guid")
	n = replaceLower(n, "Sql")
	n = replaceLower(n, "Eof")

	return n
}

func replaceLower(n, word string) string {
	return regexp.MustCompile(word+`([A-Z-_]|$)`).ReplaceAllStringFunc(n, func(s string) string {
		return strings.ToUpper(s)
	})
}

func typeName(domain, n string) string {
	if strings.Contains(n, ".") {
		list := strings.Split(n, ".")
		n = list[0] + symbol(list[1])
	} else {
		n = domain + symbol(n)
	}

	return "*" + n
}

func convertEnum(typeName string, schema gjson.Result) string {
	code := "const (\n"

	for _, val := range schema.Get("enum").Array() {
		s := val.String()
		name := typeName + symbol(s)
		code += "// " + name + " enum value\n"
		code += name + " " + typeName + "= \"" + s + "\"\n\n"
	}

	return code + ")\n"
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func snake(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}
