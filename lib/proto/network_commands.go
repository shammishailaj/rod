// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// NetworkCanClearBrowserCache (deprecated) Tells whether clearing browser cache is supported.
type NetworkCanClearBrowserCache struct {
}

// NetworkCanClearBrowserCacheResult type
type NetworkCanClearBrowserCacheResult struct {
	// Result True if browser cache can be cleared.
	Result bool `json:"result"`
}

// Call of the command, sessionID is optional.
func (m NetworkCanClearBrowserCache) Call(c *Call) (*NetworkCanClearBrowserCacheResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkCanClearBrowserCache", m)
	if err != nil {
		return nil, err
	}

	var res NetworkCanClearBrowserCacheResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkCanClearBrowserCookies (deprecated) Tells whether clearing browser cookies is supported.
type NetworkCanClearBrowserCookies struct {
}

// NetworkCanClearBrowserCookiesResult type
type NetworkCanClearBrowserCookiesResult struct {
	// Result True if browser cookies can be cleared.
	Result bool `json:"result"`
}

// Call of the command, sessionID is optional.
func (m NetworkCanClearBrowserCookies) Call(c *Call) (*NetworkCanClearBrowserCookiesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkCanClearBrowserCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkCanClearBrowserCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkCanEmulateNetworkConditions (deprecated) Tells whether emulation of network conditions is supported.
type NetworkCanEmulateNetworkConditions struct {
}

// NetworkCanEmulateNetworkConditionsResult type
type NetworkCanEmulateNetworkConditionsResult struct {
	// Result True if emulation of network conditions is supported.
	Result bool `json:"result"`
}

// Call of the command, sessionID is optional.
func (m NetworkCanEmulateNetworkConditions) Call(c *Call) (*NetworkCanEmulateNetworkConditionsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkCanEmulateNetworkConditions", m)
	if err != nil {
		return nil, err
	}

	var res NetworkCanEmulateNetworkConditionsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkClearBrowserCache Clears browser cache.
type NetworkClearBrowserCache struct {
}

// NetworkClearBrowserCacheResult type
type NetworkClearBrowserCacheResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkClearBrowserCache) Call(c *Call) (*NetworkClearBrowserCacheResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkClearBrowserCache", m)
	if err != nil {
		return nil, err
	}

	var res NetworkClearBrowserCacheResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkClearBrowserCookies Clears browser cookies.
type NetworkClearBrowserCookies struct {
}

// NetworkClearBrowserCookiesResult type
type NetworkClearBrowserCookiesResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkClearBrowserCookies) Call(c *Call) (*NetworkClearBrowserCookiesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkClearBrowserCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkClearBrowserCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkContinueInterceptedRequest (deprecated) (experimental) Response to Network.requestIntercepted which either modifies the request to continue with any
// modifications, or blocks it, or completes it with the provided response bytes. If a network
// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
// event will be sent with the same InterceptionId.
// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
type NetworkContinueInterceptedRequest struct {
	// InterceptionID ...
	InterceptionID *NetworkInterceptionID `json:"interceptionId"`

	// ErrorReason If set this causes the request to fail with the given reason. Passing `Aborted` for requests
	// marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
	// to an authChallenge.
	ErrorReason *NetworkErrorReason `json:"errorReason,omitempty"`

	// RawResponse If set the requests completes using with the provided base64 encoded raw response, including
	// HTTP status line and headers etc... Must not be set in response to an authChallenge.
	RawResponse []byte `json:"rawResponse,omitempty"`

	// URL If set the request url will be modified in a way that's not observable by page. Must not be
	// set in response to an authChallenge.
	URL string `json:"url,omitempty"`

	// Method If set this allows the request method to be overridden. Must not be set in response to an
	// authChallenge.
	Method string `json:"method,omitempty"`

	// PostData If set this allows postData to be set. Must not be set in response to an authChallenge.
	PostData string `json:"postData,omitempty"`

	// Headers If set this allows the request headers to be changed. Must not be set in response to an
	// authChallenge.
	Headers *NetworkHeaders `json:"headers,omitempty"`

	// AuthChallengeResponse Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
	AuthChallengeResponse *NetworkAuthChallengeResponse `json:"authChallengeResponse,omitempty"`
}

// NetworkContinueInterceptedRequestResult type
type NetworkContinueInterceptedRequestResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkContinueInterceptedRequest) Call(c *Call) (*NetworkContinueInterceptedRequestResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkContinueInterceptedRequest", m)
	if err != nil {
		return nil, err
	}

	var res NetworkContinueInterceptedRequestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkDeleteCookies Deletes browser cookies with matching name and url or domain/path pair.
type NetworkDeleteCookies struct {
	// Name Name of the cookies to remove.
	Name string `json:"name"`

	// URL If specified, deletes all the cookies with the given name where domain and path match
	// provided URL.
	URL string `json:"url,omitempty"`

	// Domain If specified, deletes only cookies with the exact domain.
	Domain string `json:"domain,omitempty"`

	// Path If specified, deletes only cookies with the exact path.
	Path string `json:"path,omitempty"`
}

// NetworkDeleteCookiesResult type
type NetworkDeleteCookiesResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkDeleteCookies) Call(c *Call) (*NetworkDeleteCookiesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkDeleteCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkDeleteCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkDisable Disables network tracking, prevents network events from being sent to the client.
type NetworkDisable struct {
}

// NetworkDisableResult type
type NetworkDisableResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkDisable) Call(c *Call) (*NetworkDisableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkDisable", m)
	if err != nil {
		return nil, err
	}

	var res NetworkDisableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkEmulateNetworkConditions Activates emulation of network conditions.
type NetworkEmulateNetworkConditions struct {
	// Offline True to emulate internet disconnection.
	Offline bool `json:"offline"`

	// Latency Minimum latency from request sent to response headers received (ms).
	Latency float64 `json:"latency"`

	// DownloadThroughput Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
	DownloadThroughput float64 `json:"downloadThroughput"`

	// UploadThroughput Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
	UploadThroughput float64 `json:"uploadThroughput"`

	// ConnectionType Connection type if known.
	ConnectionType *NetworkConnectionType `json:"connectionType,omitempty"`
}

// NetworkEmulateNetworkConditionsResult type
type NetworkEmulateNetworkConditionsResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkEmulateNetworkConditions) Call(c *Call) (*NetworkEmulateNetworkConditionsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkEmulateNetworkConditions", m)
	if err != nil {
		return nil, err
	}

	var res NetworkEmulateNetworkConditionsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkEnable Enables network tracking, network events will now be delivered to the client.
type NetworkEnable struct {
	// MaxTotalBufferSize (experimental) Buffer size in bytes to use when preserving network payloads (XHRs, etc).
	MaxTotalBufferSize int64 `json:"maxTotalBufferSize,omitempty"`

	// MaxResourceBufferSize (experimental) Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
	MaxResourceBufferSize int64 `json:"maxResourceBufferSize,omitempty"`

	// MaxPostDataSize Longest post body size (in bytes) that would be included in requestWillBeSent notification
	MaxPostDataSize int64 `json:"maxPostDataSize,omitempty"`
}

// NetworkEnableResult type
type NetworkEnableResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkEnable) Call(c *Call) (*NetworkEnableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkEnable", m)
	if err != nil {
		return nil, err
	}

	var res NetworkEnableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetAllCookies Returns all browser cookies. Depending on the backend support, will return detailed cookie
// information in the `cookies` field.
type NetworkGetAllCookies struct {
}

// NetworkGetAllCookiesResult type
type NetworkGetAllCookiesResult struct {
	// Cookies Array of cookie objects.
	Cookies []*NetworkCookie `json:"cookies"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetAllCookies) Call(c *Call) (*NetworkGetAllCookiesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkGetAllCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetAllCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetCertificate (experimental) Returns the DER-encoded certificate.
type NetworkGetCertificate struct {
	// Origin Origin to get certificate for.
	Origin string `json:"origin"`
}

// NetworkGetCertificateResult type
type NetworkGetCertificateResult struct {
	// TableNames ...
	TableNames []string `json:"tableNames"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetCertificate) Call(c *Call) (*NetworkGetCertificateResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkGetCertificate", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetCertificateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetCookies Returns all browser cookies for the current URL. Depending on the backend support, will return
// detailed cookie information in the `cookies` field.
type NetworkGetCookies struct {
	// Urls The list of URLs for which applicable cookies will be fetched
	Urls []string `json:"urls,omitempty"`
}

// NetworkGetCookiesResult type
type NetworkGetCookiesResult struct {
	// Cookies Array of cookie objects.
	Cookies []*NetworkCookie `json:"cookies"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetCookies) Call(c *Call) (*NetworkGetCookiesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkGetCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetResponseBody Returns content served for the given request.
type NetworkGetResponseBody struct {
	// RequestID Identifier of the network request to get content for.
	RequestID *NetworkRequestID `json:"requestId"`
}

// NetworkGetResponseBodyResult type
type NetworkGetResponseBodyResult struct {
	// Body Response body.
	Body string `json:"body"`

	// Base64Encoded True, if content was sent as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetResponseBody) Call(c *Call) (*NetworkGetResponseBodyResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkGetResponseBody", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetResponseBodyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetRequestPostData Returns post data sent with the request. Returns an error when no data was sent with the request.
type NetworkGetRequestPostData struct {
	// RequestID Identifier of the network request to get content for.
	RequestID *NetworkRequestID `json:"requestId"`
}

// NetworkGetRequestPostDataResult type
type NetworkGetRequestPostDataResult struct {
	// PostData Request body string, omitting files from multipart requests
	PostData string `json:"postData"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetRequestPostData) Call(c *Call) (*NetworkGetRequestPostDataResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkGetRequestPostData", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetRequestPostDataResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetResponseBodyForInterception (experimental) Returns content served for the given currently intercepted request.
type NetworkGetResponseBodyForInterception struct {
	// InterceptionID Identifier for the intercepted request to get body for.
	InterceptionID *NetworkInterceptionID `json:"interceptionId"`
}

// NetworkGetResponseBodyForInterceptionResult type
type NetworkGetResponseBodyForInterceptionResult struct {
	// Body Response body.
	Body string `json:"body"`

	// Base64Encoded True, if content was sent as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetResponseBodyForInterception) Call(c *Call) (*NetworkGetResponseBodyForInterceptionResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkGetResponseBodyForInterception", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetResponseBodyForInterceptionResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkTakeResponseBodyForInterceptionAsStream (experimental) Returns a handle to the stream representing the response body. Note that after this command,
// the intercepted request can't be continued as is -- you either need to cancel it or to provide
// the response body. The stream only supports sequential read, IO.read will fail if the position
// is specified.
type NetworkTakeResponseBodyForInterceptionAsStream struct {
	// InterceptionID ...
	InterceptionID *NetworkInterceptionID `json:"interceptionId"`
}

// NetworkTakeResponseBodyForInterceptionAsStreamResult type
type NetworkTakeResponseBodyForInterceptionAsStreamResult struct {
	// Stream ...
	Stream *IOStreamHandle `json:"stream"`
}

// Call of the command, sessionID is optional.
func (m NetworkTakeResponseBodyForInterceptionAsStream) Call(c *Call) (*NetworkTakeResponseBodyForInterceptionAsStreamResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkTakeResponseBodyForInterceptionAsStream", m)
	if err != nil {
		return nil, err
	}

	var res NetworkTakeResponseBodyForInterceptionAsStreamResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkReplayXHR (experimental) This method sends a new XMLHttpRequest which is identical to the original one. The following
// parameters should be identical: method, url, async, request body, extra headers, withCredentials
// attribute, user, password.
type NetworkReplayXHR struct {
	// RequestID Identifier of XHR to replay.
	RequestID *NetworkRequestID `json:"requestId"`
}

// NetworkReplayXHRResult type
type NetworkReplayXHRResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkReplayXHR) Call(c *Call) (*NetworkReplayXHRResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkReplayXHR", m)
	if err != nil {
		return nil, err
	}

	var res NetworkReplayXHRResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSearchInResponseBody (experimental) Searches for given string in response content.
type NetworkSearchInResponseBody struct {
	// RequestID Identifier of the network response to search.
	RequestID *NetworkRequestID `json:"requestId"`

	// Query String to search for.
	Query string `json:"query"`

	// CaseSensitive If true, search is case sensitive.
	CaseSensitive bool `json:"caseSensitive,omitempty"`

	// IsRegex If true, treats string parameter as regex.
	IsRegex bool `json:"isRegex,omitempty"`
}

// NetworkSearchInResponseBodyResult type
type NetworkSearchInResponseBodyResult struct {
	// Result List of search matches.
	Result []*DebuggerSearchMatch `json:"result"`
}

// Call of the command, sessionID is optional.
func (m NetworkSearchInResponseBody) Call(c *Call) (*NetworkSearchInResponseBodyResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSearchInResponseBody", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSearchInResponseBodyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetBlockedURLs (experimental) Blocks URLs from loading.
type NetworkSetBlockedURLs struct {
	// Urls URL patterns to block. Wildcards ('*') are allowed.
	Urls []string `json:"urls"`
}

// NetworkSetBlockedURLsResult type
type NetworkSetBlockedURLsResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetBlockedURLs) Call(c *Call) (*NetworkSetBlockedURLsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetBlockedURLs", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetBlockedURLsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetBypassServiceWorker (experimental) Toggles ignoring of service worker for each request.
type NetworkSetBypassServiceWorker struct {
	// Bypass Bypass service worker and load from network.
	Bypass bool `json:"bypass"`
}

// NetworkSetBypassServiceWorkerResult type
type NetworkSetBypassServiceWorkerResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetBypassServiceWorker) Call(c *Call) (*NetworkSetBypassServiceWorkerResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetBypassServiceWorker", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetBypassServiceWorkerResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetCacheDisabled Toggles ignoring cache for each request. If `true`, cache will not be used.
type NetworkSetCacheDisabled struct {
	// CacheDisabled Cache disabled state.
	CacheDisabled bool `json:"cacheDisabled"`
}

// NetworkSetCacheDisabledResult type
type NetworkSetCacheDisabledResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetCacheDisabled) Call(c *Call) (*NetworkSetCacheDisabledResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetCacheDisabled", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetCacheDisabledResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetCookie Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
type NetworkSetCookie struct {
	// Name Cookie name.
	Name string `json:"name"`

	// Value Cookie value.
	Value string `json:"value"`

	// URL The request-URI to associate with the setting of the cookie. This value can affect the
	// default domain and path values of the created cookie.
	URL string `json:"url,omitempty"`

	// Domain Cookie domain.
	Domain string `json:"domain,omitempty"`

	// Path Cookie path.
	Path string `json:"path,omitempty"`

	// Secure True if cookie is secure.
	Secure bool `json:"secure,omitempty"`

	// HTTPOnly True if cookie is http-only.
	HTTPOnly bool `json:"httpOnly,omitempty"`

	// SameSite Cookie SameSite type.
	SameSite *NetworkCookieSameSite `json:"sameSite,omitempty"`

	// Expires Cookie expiration date, session cookie if not set
	Expires *NetworkTimeSinceEpoch `json:"expires,omitempty"`

	// Priority (experimental) Cookie Priority type.
	Priority *NetworkCookiePriority `json:"priority,omitempty"`
}

// NetworkSetCookieResult type
type NetworkSetCookieResult struct {
	// Success True if successfully set cookie.
	Success bool `json:"success"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetCookie) Call(c *Call) (*NetworkSetCookieResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetCookie", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetCookieResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetCookies Sets given cookies.
type NetworkSetCookies struct {
	// Cookies Cookies to be set.
	Cookies []*NetworkCookieParam `json:"cookies"`
}

// NetworkSetCookiesResult type
type NetworkSetCookiesResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetCookies) Call(c *Call) (*NetworkSetCookiesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetDataSizeLimitsForTest (experimental) For testing.
type NetworkSetDataSizeLimitsForTest struct {
	// MaxTotalSize Maximum total buffer size.
	MaxTotalSize int64 `json:"maxTotalSize"`

	// MaxResourceSize Maximum per-resource size.
	MaxResourceSize int64 `json:"maxResourceSize"`
}

// NetworkSetDataSizeLimitsForTestResult type
type NetworkSetDataSizeLimitsForTestResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetDataSizeLimitsForTest) Call(c *Call) (*NetworkSetDataSizeLimitsForTestResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetDataSizeLimitsForTest", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetDataSizeLimitsForTestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetExtraHTTPHeaders Specifies whether to always send extra HTTP headers with the requests from this page.
type NetworkSetExtraHTTPHeaders struct {
	// Headers Map with extra HTTP headers.
	Headers *NetworkHeaders `json:"headers"`
}

// NetworkSetExtraHTTPHeadersResult type
type NetworkSetExtraHTTPHeadersResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetExtraHTTPHeaders) Call(c *Call) (*NetworkSetExtraHTTPHeadersResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetExtraHTTPHeaders", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetExtraHTTPHeadersResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetRequestInterception (deprecated) (experimental) Sets the requests to intercept that match the provided patterns and optionally resource types.
// Deprecated, please use Fetch.enable instead.
type NetworkSetRequestInterception struct {
	// Patterns Requests matching any of these patterns will be forwarded and wait for the corresponding
	// continueInterceptedRequest call.
	Patterns []*NetworkRequestPattern `json:"patterns"`
}

// NetworkSetRequestInterceptionResult type
type NetworkSetRequestInterceptionResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetRequestInterception) Call(c *Call) (*NetworkSetRequestInterceptionResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetRequestInterception", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetRequestInterceptionResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetUserAgentOverride Allows overriding user agent with the given string.
type NetworkSetUserAgentOverride struct {
	// UserAgent User agent to use.
	UserAgent string `json:"userAgent"`

	// AcceptLanguage Browser langugage to emulate.
	AcceptLanguage string `json:"acceptLanguage,omitempty"`

	// Platform The platform navigator.platform should return.
	Platform string `json:"platform,omitempty"`
}

// NetworkSetUserAgentOverrideResult type
type NetworkSetUserAgentOverrideResult struct {
}

// Call of the command, sessionID is optional.
func (m NetworkSetUserAgentOverride) Call(c *Call) (*NetworkSetUserAgentOverrideResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "NetworkSetUserAgentOverride", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetUserAgentOverrideResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
