// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// HeadlessExperimentalBeginFrame Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
// screenshot from the resulting frame. Requires that the target was created with enabled
// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
// https://goo.gl/3zHXhB for more background.
type HeadlessExperimentalBeginFrame struct {
	// FrameTimeTicks Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
	// the current time will be used.
	FrameTimeTicks float64 `json:"frameTimeTicks,omitempty"`

	// Interval The interval between BeginFrames that is reported to the compositor, in milliseconds.
	// Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
	Interval float64 `json:"interval,omitempty"`

	// NoDisplayUpdates Whether updates should not be committed and drawn onto the display. False by default. If
	// true, only side effects of the BeginFrame will be run, such as layout and animations, but
	// any visual updates may not be visible on the display or in screenshots.
	NoDisplayUpdates bool `json:"noDisplayUpdates,omitempty"`

	// Screenshot If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
	// no screenshot will be captured. Note that capturing a screenshot can fail, for example,
	// during renderer initialization. In such a case, no screenshot data will be returned.
	Screenshot *HeadlessExperimentalScreenshotParams `json:"screenshot,omitempty"`
}

// HeadlessExperimentalBeginFrameResult type
type HeadlessExperimentalBeginFrameResult struct {
	// HasDamage Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
	// display. Reported for diagnostic uses, may be removed in the future.
	HasDamage bool `json:"hasDamage"`

	// ScreenshotData Base64-encoded image data of the screenshot, if one was requested and successfully taken.
	ScreenshotData []byte `json:"screenshotData,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeadlessExperimentalBeginFrame) Call(c *Call) (*HeadlessExperimentalBeginFrameResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "HeadlessExperimentalBeginFrame", m)
	if err != nil {
		return nil, err
	}

	var res HeadlessExperimentalBeginFrameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeadlessExperimentalDisable Disables headless events for the target.
type HeadlessExperimentalDisable struct {
}

// HeadlessExperimentalDisableResult type
type HeadlessExperimentalDisableResult struct {
}

// Call of the command, sessionID is optional.
func (m HeadlessExperimentalDisable) Call(c *Call) (*HeadlessExperimentalDisableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "HeadlessExperimentalDisable", m)
	if err != nil {
		return nil, err
	}

	var res HeadlessExperimentalDisableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeadlessExperimentalEnable Enables headless events for the target.
type HeadlessExperimentalEnable struct {
}

// HeadlessExperimentalEnableResult type
type HeadlessExperimentalEnableResult struct {
}

// Call of the command, sessionID is optional.
func (m HeadlessExperimentalEnable) Call(c *Call) (*HeadlessExperimentalEnableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "HeadlessExperimentalEnable", m)
	if err != nil {
		return nil, err
	}

	var res HeadlessExperimentalEnableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
