// This file is generated by "./lib/proto/cmd/gen"

package proto

import "encoding/json"

// FetchRequestPaused Issued when the domain is enabled and the request URL matches the
// specified filter. The request is paused until the client responds
// with one of continueRequest, failRequest or fulfillRequest.
// The stage of the request can be determined by presence of responseErrorReason
// and responseStatusCode -- the request is at the response stage if either
// of these fields is present and in the request stage otherwise.
type FetchRequestPaused struct {
	// RequestID Each request the page makes will have a unique id.
	RequestID *FetchRequestID `json:"requestId"`

	// Request The details of the request.
	Request *NetworkRequest `json:"request"`

	// FrameID The id of the frame that initiated the request.
	FrameID *PageFrameID `json:"frameId"`

	// ResourceType How the requested resource will be used.
	ResourceType *NetworkResourceType `json:"resourceType"`

	// ResponseErrorReason Response error if intercepted at response stage.
	ResponseErrorReason *NetworkErrorReason `json:"responseErrorReason,omitempty"`

	// ResponseStatusCode Response code if intercepted at response stage.
	ResponseStatusCode int64 `json:"responseStatusCode,omitempty"`

	// ResponseHeaders Response headers if intercepted at the response stage.
	ResponseHeaders []*FetchHeaderEntry `json:"responseHeaders,omitempty"`

	// NetworkID If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
	// then this networkId will be the same as the requestId present in the requestWillBeSent event.
	NetworkID *FetchRequestID `json:"networkId,omitempty"`
}

// MethodName interface
func (evt FetchRequestPaused) MethodName() string {
	return "Fetch.requestPaused"
}

// Load json
func (evt FetchRequestPaused) Load(b []byte) *FetchRequestPaused {
	E(json.Unmarshal(b, &evt))
	return &evt
}

// FetchAuthRequired Issued when the domain is enabled with handleAuthRequests set to true.
// The request is paused until client responds with continueWithAuth.
type FetchAuthRequired struct {
	// RequestID Each request the page makes will have a unique id.
	RequestID *FetchRequestID `json:"requestId"`

	// Request The details of the request.
	Request *NetworkRequest `json:"request"`

	// FrameID The id of the frame that initiated the request.
	FrameID *PageFrameID `json:"frameId"`

	// ResourceType How the requested resource will be used.
	ResourceType *NetworkResourceType `json:"resourceType"`

	// AuthChallenge Details of the Authorization Challenge encountered.
	// If this is set, client should respond with continueRequest that
	// contains AuthChallengeResponse.
	AuthChallenge *FetchAuthChallenge `json:"authChallenge"`
}

// MethodName interface
func (evt FetchAuthRequired) MethodName() string {
	return "Fetch.authRequired"
}

// Load json
func (evt FetchAuthRequired) Load(b []byte) *FetchAuthRequired {
	E(json.Unmarshal(b, &evt))
	return &evt
}
