// This file is generated by "./lib/proto/cmd/gen"

package proto

import "encoding/json"

// DebuggerBreakpointResolved Fired when breakpoint is resolved to an actual script and location.
type DebuggerBreakpointResolved struct {
	// BreakpointID Breakpoint unique identifier.
	BreakpointID *DebuggerBreakpointID `json:"breakpointId"`

	// Location Actual breakpoint location.
	Location *DebuggerLocation `json:"location"`
}

// MethodName interface
func (evt DebuggerBreakpointResolved) MethodName() string {
	return "Debugger.breakpointResolved"
}

// Load json
func (evt DebuggerBreakpointResolved) Load(b []byte) *DebuggerBreakpointResolved {
	E(json.Unmarshal(b, &evt))
	return &evt
}

// DebuggerPaused Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
type DebuggerPaused struct {
	// CallFrames Call stack the virtual machine stopped on.
	CallFrames []*DebuggerCallFrame `json:"callFrames"`

	// Reason Pause reason.
	Reason string `json:"reason"`

	// Data Object containing break-specific auxiliary properties.
	Data map[string]interface{} `json:"data,omitempty"`

	// HitBreakpoints Hit breakpoints IDs
	HitBreakpoints []string `json:"hitBreakpoints,omitempty"`

	// AsyncStackTrace Async stack trace, if any.
	AsyncStackTrace *RuntimeStackTrace `json:"asyncStackTrace,omitempty"`

	// AsyncStackTraceID (experimental) Async stack trace, if any.
	AsyncStackTraceID *RuntimeStackTraceID `json:"asyncStackTraceId,omitempty"`

	// AsyncCallStackTraceID (deprecated) (experimental) Never present, will be removed.
	AsyncCallStackTraceID *RuntimeStackTraceID `json:"asyncCallStackTraceId,omitempty"`
}

// MethodName interface
func (evt DebuggerPaused) MethodName() string {
	return "Debugger.paused"
}

// Load json
func (evt DebuggerPaused) Load(b []byte) *DebuggerPaused {
	E(json.Unmarshal(b, &evt))
	return &evt
}

// DebuggerResumed Fired when the virtual machine resumed execution.
type DebuggerResumed struct {
}

// MethodName interface
func (evt DebuggerResumed) MethodName() string {
	return "Debugger.resumed"
}

// Load json
func (evt DebuggerResumed) Load(b []byte) *DebuggerResumed {
	E(json.Unmarshal(b, &evt))
	return &evt
}

// DebuggerScriptFailedToParse Fired when virtual machine fails to parse the script.
type DebuggerScriptFailedToParse struct {
	// ScriptID Identifier of the script parsed.
	ScriptID *RuntimeScriptID `json:"scriptId"`

	// URL URL or name of the script parsed (if any).
	URL string `json:"url"`

	// StartLine Line offset of the script within the resource with given URL (for script tags).
	StartLine int64 `json:"startLine"`

	// StartColumn Column offset of the script within the resource with given URL.
	StartColumn int64 `json:"startColumn"`

	// EndLine Last line of the script.
	EndLine int64 `json:"endLine"`

	// EndColumn Length of the last line of the script.
	EndColumn int64 `json:"endColumn"`

	// ExecutionContextID Specifies script creation context.
	ExecutionContextID *RuntimeExecutionContextID `json:"executionContextId"`

	// Hash Content hash of the script.
	Hash string `json:"hash"`

	// ExecutionContextAuxData Embedder-specific auxiliary data.
	ExecutionContextAuxData map[string]interface{} `json:"executionContextAuxData,omitempty"`

	// SourceMapURL URL of source map associated with script (if any).
	SourceMapURL string `json:"sourceMapURL,omitempty"`

	// HasSourceURL True, if this script has sourceURL.
	HasSourceURL bool `json:"hasSourceURL,omitempty"`

	// IsModule True, if this script is ES6 module.
	IsModule bool `json:"isModule,omitempty"`

	// Length This script length.
	Length int64 `json:"length,omitempty"`

	// StackTrace (experimental) JavaScript top stack frame of where the script parsed event was triggered if available.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`
}

// MethodName interface
func (evt DebuggerScriptFailedToParse) MethodName() string {
	return "Debugger.scriptFailedToParse"
}

// Load json
func (evt DebuggerScriptFailedToParse) Load(b []byte) *DebuggerScriptFailedToParse {
	E(json.Unmarshal(b, &evt))
	return &evt
}

// DebuggerScriptParsed Fired when virtual machine parses script. This event is also fired for all known and uncollected
// scripts upon enabling debugger.
type DebuggerScriptParsed struct {
	// ScriptID Identifier of the script parsed.
	ScriptID *RuntimeScriptID `json:"scriptId"`

	// URL URL or name of the script parsed (if any).
	URL string `json:"url"`

	// StartLine Line offset of the script within the resource with given URL (for script tags).
	StartLine int64 `json:"startLine"`

	// StartColumn Column offset of the script within the resource with given URL.
	StartColumn int64 `json:"startColumn"`

	// EndLine Last line of the script.
	EndLine int64 `json:"endLine"`

	// EndColumn Length of the last line of the script.
	EndColumn int64 `json:"endColumn"`

	// ExecutionContextID Specifies script creation context.
	ExecutionContextID *RuntimeExecutionContextID `json:"executionContextId"`

	// Hash Content hash of the script.
	Hash string `json:"hash"`

	// ExecutionContextAuxData Embedder-specific auxiliary data.
	ExecutionContextAuxData map[string]interface{} `json:"executionContextAuxData,omitempty"`

	// IsLiveEdit (experimental) True, if this script is generated as a result of the live edit operation.
	IsLiveEdit bool `json:"isLiveEdit,omitempty"`

	// SourceMapURL URL of source map associated with script (if any).
	SourceMapURL string `json:"sourceMapURL,omitempty"`

	// HasSourceURL True, if this script has sourceURL.
	HasSourceURL bool `json:"hasSourceURL,omitempty"`

	// IsModule True, if this script is ES6 module.
	IsModule bool `json:"isModule,omitempty"`

	// Length This script length.
	Length int64 `json:"length,omitempty"`

	// StackTrace (experimental) JavaScript top stack frame of where the script parsed event was triggered if available.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`
}

// MethodName interface
func (evt DebuggerScriptParsed) MethodName() string {
	return "Debugger.scriptParsed"
}

// Load json
func (evt DebuggerScriptParsed) Load(b []byte) *DebuggerScriptParsed {
	E(json.Unmarshal(b, &evt))
	return &evt
}
