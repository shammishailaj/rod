// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// DOMCollectClassNamesFromSubtree (experimental) Collects class names for the node with given id and all of it's child nodes.
type DOMCollectClassNamesFromSubtree struct {
	// NodeID Id of the node to collect class names.
	NodeID *DOMNodeID `json:"nodeId"`
}

// DOMCollectClassNamesFromSubtreeResult type
type DOMCollectClassNamesFromSubtreeResult struct {
	// ClassNames Class name list.
	ClassNames []string `json:"classNames"`
}

// Call of the command, sessionID is optional.
func (m DOMCollectClassNamesFromSubtree) Call(c *Call) (*DOMCollectClassNamesFromSubtreeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMCollectClassNamesFromSubtree", m)
	if err != nil {
		return nil, err
	}

	var res DOMCollectClassNamesFromSubtreeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMCopyTo (experimental) Creates a deep copy of the specified node and places it into the target container before the
// given anchor.
type DOMCopyTo struct {
	// NodeID Id of the node to copy.
	NodeID *DOMNodeID `json:"nodeId"`

	// TargetNodeID Id of the element to drop the copy into.
	TargetNodeID *DOMNodeID `json:"targetNodeId"`

	// InsertBeforeNodeID Drop the copy before this node (if absent, the copy becomes the last child of
	// `targetNodeId`).
	InsertBeforeNodeID *DOMNodeID `json:"insertBeforeNodeId,omitempty"`
}

// DOMCopyToResult type
type DOMCopyToResult struct {
	// NodeID Id of the node clone.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMCopyTo) Call(c *Call) (*DOMCopyToResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMCopyTo", m)
	if err != nil {
		return nil, err
	}

	var res DOMCopyToResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMDescribeNode Describes node given its id, does not require domain to be enabled. Does not start tracking any
// objects, can be used for automation.
type DOMDescribeNode struct {
	// NodeID Identifier of the node.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Identifier of the backend node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId,omitempty"`

	// Depth The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// DOMDescribeNodeResult type
type DOMDescribeNodeResult struct {
	// Node Node description.
	Node *DOMNode `json:"node"`
}

// Call of the command, sessionID is optional.
func (m DOMDescribeNode) Call(c *Call) (*DOMDescribeNodeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMDescribeNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMDescribeNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMDisable Disables DOM agent for the given page.
type DOMDisable struct {
}

// DOMDisableResult type
type DOMDisableResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMDisable) Call(c *Call) (*DOMDisableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMDisable", m)
	if err != nil {
		return nil, err
	}

	var res DOMDisableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMDiscardSearchResults (experimental) Discards search results from the session with the given id. `getSearchResults` should no longer
// be called for that search.
type DOMDiscardSearchResults struct {
	// SearchID Unique search session identifier.
	SearchID string `json:"searchId"`
}

// DOMDiscardSearchResultsResult type
type DOMDiscardSearchResultsResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMDiscardSearchResults) Call(c *Call) (*DOMDiscardSearchResultsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMDiscardSearchResults", m)
	if err != nil {
		return nil, err
	}

	var res DOMDiscardSearchResultsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMEnable Enables DOM agent for the given page.
type DOMEnable struct {
}

// DOMEnableResult type
type DOMEnableResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMEnable) Call(c *Call) (*DOMEnableResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMEnable", m)
	if err != nil {
		return nil, err
	}

	var res DOMEnableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMFocus Focuses the given element.
type DOMFocus struct {
	// NodeID Identifier of the node.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Identifier of the backend node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// DOMFocusResult type
type DOMFocusResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMFocus) Call(c *Call) (*DOMFocusResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMFocus", m)
	if err != nil {
		return nil, err
	}

	var res DOMFocusResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetAttributes Returns attributes for the specified node.
type DOMGetAttributes struct {
	// NodeID Id of the node to retrieve attibutes for.
	NodeID *DOMNodeID `json:"nodeId"`
}

// DOMGetAttributesResult type
type DOMGetAttributesResult struct {
	// Attributes An interleaved array of node attribute names and values.
	Attributes []string `json:"attributes"`
}

// Call of the command, sessionID is optional.
func (m DOMGetAttributes) Call(c *Call) (*DOMGetAttributesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetAttributes", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetAttributesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetBoxModel Returns boxes for the given node.
type DOMGetBoxModel struct {
	// NodeID Identifier of the node.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Identifier of the backend node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// DOMGetBoxModelResult type
type DOMGetBoxModelResult struct {
	// Model Box model for the node.
	Model *DOMBoxModel `json:"model"`
}

// Call of the command, sessionID is optional.
func (m DOMGetBoxModel) Call(c *Call) (*DOMGetBoxModelResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetBoxModel", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetBoxModelResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetContentQuads (experimental) Returns quads that describe node position on the page. This method
// might return multiple quads for inline nodes.
type DOMGetContentQuads struct {
	// NodeID Identifier of the node.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Identifier of the backend node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// DOMGetContentQuadsResult type
type DOMGetContentQuadsResult struct {
	// Quads Quads that describe node layout relative to viewport.
	Quads []*DOMQuad `json:"quads"`
}

// Call of the command, sessionID is optional.
func (m DOMGetContentQuads) Call(c *Call) (*DOMGetContentQuadsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetContentQuads", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetContentQuadsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetDocument Returns the root DOM node (and optionally the subtree) to the caller.
type DOMGetDocument struct {
	// Depth The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// DOMGetDocumentResult type
type DOMGetDocumentResult struct {
	// Root Resulting node.
	Root *DOMNode `json:"root"`
}

// Call of the command, sessionID is optional.
func (m DOMGetDocument) Call(c *Call) (*DOMGetDocumentResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetDocument", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetDocumentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetFlattenedDocument Returns the root DOM node (and optionally the subtree) to the caller.
type DOMGetFlattenedDocument struct {
	// Depth The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// DOMGetFlattenedDocumentResult type
type DOMGetFlattenedDocumentResult struct {
	// Nodes Resulting node.
	Nodes []*DOMNode `json:"nodes"`
}

// Call of the command, sessionID is optional.
func (m DOMGetFlattenedDocument) Call(c *Call) (*DOMGetFlattenedDocumentResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetFlattenedDocument", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetFlattenedDocumentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetNodeForLocation Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
// either returned or not.
type DOMGetNodeForLocation struct {
	// X X coordinate.
	X int64 `json:"x"`

	// Y Y coordinate.
	Y int64 `json:"y"`

	// IncludeUserAgentShadowDOM False to skip to the nearest non-UA shadow root ancestor (default: false).
	IncludeUserAgentShadowDOM bool `json:"includeUserAgentShadowDOM,omitempty"`

	// IgnorePointerEventsNone Whether to ignore pointer-events: none on elements and hit test them.
	IgnorePointerEventsNone bool `json:"ignorePointerEventsNone,omitempty"`
}

// DOMGetNodeForLocationResult type
type DOMGetNodeForLocationResult struct {
	// BackendNodeID Resulting node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId"`

	// FrameID Frame this node belongs to.
	FrameID *PageFrameID `json:"frameId"`

	// NodeID Id of the node at given coordinates, only when enabled and requested document.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetNodeForLocation) Call(c *Call) (*DOMGetNodeForLocationResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetNodeForLocation", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetNodeForLocationResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetOuterHTML Returns node's HTML markup.
type DOMGetOuterHTML struct {
	// NodeID Identifier of the node.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Identifier of the backend node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// DOMGetOuterHTMLResult type
type DOMGetOuterHTMLResult struct {
	// OuterHTML Outer HTML markup.
	OuterHTML string `json:"outerHTML"`
}

// Call of the command, sessionID is optional.
func (m DOMGetOuterHTML) Call(c *Call) (*DOMGetOuterHTMLResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetOuterHTML", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetOuterHTMLResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetRelayoutBoundary (experimental) Returns the id of the nearest ancestor that is a relayout boundary.
type DOMGetRelayoutBoundary struct {
	// NodeID Id of the node.
	NodeID *DOMNodeID `json:"nodeId"`
}

// DOMGetRelayoutBoundaryResult type
type DOMGetRelayoutBoundaryResult struct {
	// NodeID Relayout boundary node id for the given node.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMGetRelayoutBoundary) Call(c *Call) (*DOMGetRelayoutBoundaryResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetRelayoutBoundary", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetRelayoutBoundaryResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetSearchResults (experimental) Returns search results from given `fromIndex` to given `toIndex` from the search with the given
// identifier.
type DOMGetSearchResults struct {
	// SearchID Unique search session identifier.
	SearchID string `json:"searchId"`

	// FromIndex Start index of the search result to be returned.
	FromIndex int64 `json:"fromIndex"`

	// ToIndex End index of the search result to be returned.
	ToIndex int64 `json:"toIndex"`
}

// DOMGetSearchResultsResult type
type DOMGetSearchResultsResult struct {
	// NodeIds Ids of the search result nodes.
	NodeIds []*DOMNodeID `json:"nodeIds"`
}

// Call of the command, sessionID is optional.
func (m DOMGetSearchResults) Call(c *Call) (*DOMGetSearchResultsResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetSearchResults", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetSearchResultsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMHideHighlight Hides any highlight.
type DOMHideHighlight struct {
}

// DOMHideHighlightResult type
type DOMHideHighlightResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMHideHighlight) Call(c *Call) (*DOMHideHighlightResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMHideHighlight", m)
	if err != nil {
		return nil, err
	}

	var res DOMHideHighlightResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMHighlightNode Highlights DOM node.
type DOMHighlightNode struct {
}

// DOMHighlightNodeResult type
type DOMHighlightNodeResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMHighlightNode) Call(c *Call) (*DOMHighlightNodeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMHighlightNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMHighlightNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMHighlightRect Highlights given rectangle.
type DOMHighlightRect struct {
}

// DOMHighlightRectResult type
type DOMHighlightRectResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMHighlightRect) Call(c *Call) (*DOMHighlightRectResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMHighlightRect", m)
	if err != nil {
		return nil, err
	}

	var res DOMHighlightRectResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMMarkUndoableState (experimental) Marks last undoable state.
type DOMMarkUndoableState struct {
}

// DOMMarkUndoableStateResult type
type DOMMarkUndoableStateResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMMarkUndoableState) Call(c *Call) (*DOMMarkUndoableStateResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMMarkUndoableState", m)
	if err != nil {
		return nil, err
	}

	var res DOMMarkUndoableStateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMMoveTo Moves node into the new container, places it before the given anchor.
type DOMMoveTo struct {
	// NodeID Id of the node to move.
	NodeID *DOMNodeID `json:"nodeId"`

	// TargetNodeID Id of the element to drop the moved node into.
	TargetNodeID *DOMNodeID `json:"targetNodeId"`

	// InsertBeforeNodeID Drop node before this one (if absent, the moved node becomes the last child of
	// `targetNodeId`).
	InsertBeforeNodeID *DOMNodeID `json:"insertBeforeNodeId,omitempty"`
}

// DOMMoveToResult type
type DOMMoveToResult struct {
	// NodeID New id of the moved node.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMMoveTo) Call(c *Call) (*DOMMoveToResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMMoveTo", m)
	if err != nil {
		return nil, err
	}

	var res DOMMoveToResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMPerformSearch (experimental) Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
// `cancelSearch` to end this search session.
type DOMPerformSearch struct {
	// Query Plain text or query selector or XPath search query.
	Query string `json:"query"`

	// IncludeUserAgentShadowDOM True to search in user agent shadow DOM.
	IncludeUserAgentShadowDOM bool `json:"includeUserAgentShadowDOM,omitempty"`
}

// DOMPerformSearchResult type
type DOMPerformSearchResult struct {
	// SearchID Unique search session identifier.
	SearchID string `json:"searchId"`

	// ResultCount Number of search results.
	ResultCount int64 `json:"resultCount"`
}

// Call of the command, sessionID is optional.
func (m DOMPerformSearch) Call(c *Call) (*DOMPerformSearchResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMPerformSearch", m)
	if err != nil {
		return nil, err
	}

	var res DOMPerformSearchResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMPushNodeByPathToFrontend (experimental) Requests that the node is sent to the caller given its path. // FIXME, use XPath
type DOMPushNodeByPathToFrontend struct {
	// Path Path to node in the proprietary format.
	Path string `json:"path"`
}

// DOMPushNodeByPathToFrontendResult type
type DOMPushNodeByPathToFrontendResult struct {
	// NodeID Id of the node for given path.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMPushNodeByPathToFrontend) Call(c *Call) (*DOMPushNodeByPathToFrontendResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMPushNodeByPathToFrontend", m)
	if err != nil {
		return nil, err
	}

	var res DOMPushNodeByPathToFrontendResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMPushNodesByBackendIdsToFrontend (experimental) Requests that a batch of nodes is sent to the caller given their backend node ids.
type DOMPushNodesByBackendIdsToFrontend struct {
	// BackendNodeIds The array of backend node ids.
	BackendNodeIds []*DOMBackendNodeID `json:"backendNodeIds"`
}

// DOMPushNodesByBackendIdsToFrontendResult type
type DOMPushNodesByBackendIdsToFrontendResult struct {
	// NodeIds The array of ids of pushed nodes that correspond to the backend ids specified in
	// backendNodeIds.
	NodeIds []*DOMNodeID `json:"nodeIds"`
}

// Call of the command, sessionID is optional.
func (m DOMPushNodesByBackendIdsToFrontend) Call(c *Call) (*DOMPushNodesByBackendIdsToFrontendResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMPushNodesByBackendIdsToFrontend", m)
	if err != nil {
		return nil, err
	}

	var res DOMPushNodesByBackendIdsToFrontendResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMQuerySelector Executes `querySelector` on a given node.
type DOMQuerySelector struct {
	// NodeID Id of the node to query upon.
	NodeID *DOMNodeID `json:"nodeId"`

	// Selector Selector string.
	Selector string `json:"selector"`
}

// DOMQuerySelectorResult type
type DOMQuerySelectorResult struct {
	// NodeID Query selector result.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMQuerySelector) Call(c *Call) (*DOMQuerySelectorResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMQuerySelector", m)
	if err != nil {
		return nil, err
	}

	var res DOMQuerySelectorResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMQuerySelectorAll Executes `querySelectorAll` on a given node.
type DOMQuerySelectorAll struct {
	// NodeID Id of the node to query upon.
	NodeID *DOMNodeID `json:"nodeId"`

	// Selector Selector string.
	Selector string `json:"selector"`
}

// DOMQuerySelectorAllResult type
type DOMQuerySelectorAllResult struct {
	// NodeIds Query selector result.
	NodeIds []*DOMNodeID `json:"nodeIds"`
}

// Call of the command, sessionID is optional.
func (m DOMQuerySelectorAll) Call(c *Call) (*DOMQuerySelectorAllResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMQuerySelectorAll", m)
	if err != nil {
		return nil, err
	}

	var res DOMQuerySelectorAllResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMRedo (experimental) Re-does the last undone action.
type DOMRedo struct {
}

// DOMRedoResult type
type DOMRedoResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMRedo) Call(c *Call) (*DOMRedoResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMRedo", m)
	if err != nil {
		return nil, err
	}

	var res DOMRedoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMRemoveAttribute Removes attribute with given name from an element with given id.
type DOMRemoveAttribute struct {
	// NodeID Id of the element to remove attribute from.
	NodeID *DOMNodeID `json:"nodeId"`

	// Name Name of the attribute to remove.
	Name string `json:"name"`
}

// DOMRemoveAttributeResult type
type DOMRemoveAttributeResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMRemoveAttribute) Call(c *Call) (*DOMRemoveAttributeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMRemoveAttribute", m)
	if err != nil {
		return nil, err
	}

	var res DOMRemoveAttributeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMRemoveNode Removes node with given id.
type DOMRemoveNode struct {
	// NodeID Id of the node to remove.
	NodeID *DOMNodeID `json:"nodeId"`
}

// DOMRemoveNodeResult type
type DOMRemoveNodeResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMRemoveNode) Call(c *Call) (*DOMRemoveNodeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMRemoveNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMRemoveNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMRequestChildNodes Requests that children of the node with given id are returned to the caller in form of
// `setChildNodes` events where not only immediate children are retrieved, but all children down to
// the specified depth.
type DOMRequestChildNodes struct {
	// NodeID Id of the node to get children for.
	NodeID *DOMNodeID `json:"nodeId"`

	// Depth The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce Whether or not iframes and shadow roots should be traversed when returning the sub-tree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// DOMRequestChildNodesResult type
type DOMRequestChildNodesResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMRequestChildNodes) Call(c *Call) (*DOMRequestChildNodesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMRequestChildNodes", m)
	if err != nil {
		return nil, err
	}

	var res DOMRequestChildNodesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMRequestNode Requests that the node is sent to the caller given the JavaScript node object reference. All
// nodes that form the path from the node to the root are also sent to the client as a series of
// `setChildNodes` notifications.
type DOMRequestNode struct {
	// ObjectID JavaScript object id to convert into node.
	ObjectID *RuntimeRemoteObjectID `json:"objectId"`
}

// DOMRequestNodeResult type
type DOMRequestNodeResult struct {
	// NodeID Node id for given object.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMRequestNode) Call(c *Call) (*DOMRequestNodeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMRequestNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMRequestNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMResolveNode Resolves the JavaScript node object for a given NodeId or BackendNodeId.
type DOMResolveNode struct {
	// NodeID Id of the node to resolve.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Backend identifier of the node to resolve.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectGroup Symbolic group name that can be used to release multiple objects.
	ObjectGroup string `json:"objectGroup,omitempty"`

	// ExecutionContextID Execution context in which to resolve the node.
	ExecutionContextID *RuntimeExecutionContextID `json:"executionContextId,omitempty"`
}

// DOMResolveNodeResult type
type DOMResolveNodeResult struct {
	// Object JavaScript object wrapper for given node.
	Object *RuntimeRemoteObject `json:"object"`
}

// Call of the command, sessionID is optional.
func (m DOMResolveNode) Call(c *Call) (*DOMResolveNodeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMResolveNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMResolveNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetAttributeValue Sets attribute for an element with given id.
type DOMSetAttributeValue struct {
	// NodeID Id of the element to set attribute for.
	NodeID *DOMNodeID `json:"nodeId"`

	// Name Attribute name.
	Name string `json:"name"`

	// Value Attribute value.
	Value string `json:"value"`
}

// DOMSetAttributeValueResult type
type DOMSetAttributeValueResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetAttributeValue) Call(c *Call) (*DOMSetAttributeValueResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetAttributeValue", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetAttributeValueResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetAttributesAsText Sets attributes on element with given id. This method is useful when user edits some existing
// attribute value and types in several attribute name/value pairs.
type DOMSetAttributesAsText struct {
	// NodeID Id of the element to set attributes for.
	NodeID *DOMNodeID `json:"nodeId"`

	// Text Text with a number of attributes. Will parse this text using HTML parser.
	Text string `json:"text"`

	// Name Attribute name to replace with new attributes derived from text in case text parsed
	// successfully.
	Name string `json:"name,omitempty"`
}

// DOMSetAttributesAsTextResult type
type DOMSetAttributesAsTextResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetAttributesAsText) Call(c *Call) (*DOMSetAttributesAsTextResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetAttributesAsText", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetAttributesAsTextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetFileInputFiles Sets files for the given file input element.
type DOMSetFileInputFiles struct {
	// Files Array of file paths to set.
	Files []string `json:"files"`

	// NodeID Identifier of the node.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID Identifier of the backend node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// DOMSetFileInputFilesResult type
type DOMSetFileInputFilesResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetFileInputFiles) Call(c *Call) (*DOMSetFileInputFilesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetFileInputFiles", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetFileInputFilesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetNodeStackTracesEnabled (experimental) Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
type DOMSetNodeStackTracesEnabled struct {
	// Enable Enable or disable.
	Enable bool `json:"enable"`
}

// DOMSetNodeStackTracesEnabledResult type
type DOMSetNodeStackTracesEnabledResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetNodeStackTracesEnabled) Call(c *Call) (*DOMSetNodeStackTracesEnabledResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetNodeStackTracesEnabled", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetNodeStackTracesEnabledResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetNodeStackTraces (experimental) Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
type DOMGetNodeStackTraces struct {
	// NodeID Id of the node to get stack traces for.
	NodeID *DOMNodeID `json:"nodeId"`
}

// DOMGetNodeStackTracesResult type
type DOMGetNodeStackTracesResult struct {
	// Creation Creation stack trace, if available.
	Creation *RuntimeStackTrace `json:"creation,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetNodeStackTraces) Call(c *Call) (*DOMGetNodeStackTracesResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetNodeStackTraces", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetNodeStackTracesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetFileInfo (experimental) Returns file information for the given
// File wrapper.
type DOMGetFileInfo struct {
	// ObjectID JavaScript object id of the node wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId"`
}

// DOMGetFileInfoResult type
type DOMGetFileInfoResult struct {
	// Path ...
	Path string `json:"path"`
}

// Call of the command, sessionID is optional.
func (m DOMGetFileInfo) Call(c *Call) (*DOMGetFileInfoResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetFileInfo", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetFileInfoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetInspectedNode (experimental) Enables console to refer to the node with given id via $x (see Command Line API for more details
// $x functions).
type DOMSetInspectedNode struct {
	// NodeID DOM node id to be accessible by means of $x command line API.
	NodeID *DOMNodeID `json:"nodeId"`
}

// DOMSetInspectedNodeResult type
type DOMSetInspectedNodeResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetInspectedNode) Call(c *Call) (*DOMSetInspectedNodeResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetInspectedNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetInspectedNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetNodeName Sets node name for a node with given id.
type DOMSetNodeName struct {
	// NodeID Id of the node to set name for.
	NodeID *DOMNodeID `json:"nodeId"`

	// Name New node's name.
	Name string `json:"name"`
}

// DOMSetNodeNameResult type
type DOMSetNodeNameResult struct {
	// NodeID New node's id.
	NodeID *DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMSetNodeName) Call(c *Call) (*DOMSetNodeNameResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetNodeName", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetNodeNameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetNodeValue Sets node value for a node with given id.
type DOMSetNodeValue struct {
	// NodeID Id of the node to set value for.
	NodeID *DOMNodeID `json:"nodeId"`

	// Value New node's value.
	Value string `json:"value"`
}

// DOMSetNodeValueResult type
type DOMSetNodeValueResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetNodeValue) Call(c *Call) (*DOMSetNodeValueResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetNodeValue", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetNodeValueResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetOuterHTML Sets node HTML markup, returns new node id.
type DOMSetOuterHTML struct {
	// NodeID Id of the node to set markup for.
	NodeID *DOMNodeID `json:"nodeId"`

	// OuterHTML Outer HTML markup to set.
	OuterHTML string `json:"outerHTML"`
}

// DOMSetOuterHTMLResult type
type DOMSetOuterHTMLResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMSetOuterHTML) Call(c *Call) (*DOMSetOuterHTMLResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMSetOuterHTML", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetOuterHTMLResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMUndo (experimental) Undoes the last performed action.
type DOMUndo struct {
}

// DOMUndoResult type
type DOMUndoResult struct {
}

// Call of the command, sessionID is optional.
func (m DOMUndo) Call(c *Call) (*DOMUndoResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMUndo", m)
	if err != nil {
		return nil, err
	}

	var res DOMUndoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetFrameOwner (experimental) Returns iframe node that owns iframe with the given domain.
type DOMGetFrameOwner struct {
	// FrameID ...
	FrameID *PageFrameID `json:"frameId"`
}

// DOMGetFrameOwnerResult type
type DOMGetFrameOwnerResult struct {
	// BackendNodeID Resulting node.
	BackendNodeID *DOMBackendNodeID `json:"backendNodeId"`

	// NodeID Id of the node at given coordinates, only when enabled and requested document.
	NodeID *DOMNodeID `json:"nodeId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetFrameOwner) Call(c *Call) (*DOMGetFrameOwnerResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "DOMGetFrameOwner", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetFrameOwnerResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
