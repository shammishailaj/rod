// This file is generated by "./lib/proto/cmd/gen"

package proto

import (
	"encoding/json"
)

// IOClose Close the stream, discard any temporary backing storage.
type IOClose struct {
	// Handle Handle of the stream to close.
	Handle *IOStreamHandle `json:"handle"`
}

// IOCloseResult type
type IOCloseResult struct {
}

// Call of the command, sessionID is optional.
func (m IOClose) Call(c *Call) (*IOCloseResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "IOClose", m)
	if err != nil {
		return nil, err
	}

	var res IOCloseResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IORead Read a chunk of the stream
type IORead struct {
	// Handle Handle of the stream to read.
	Handle *IOStreamHandle `json:"handle"`

	// Offset Seek to the specified offset before reading (if not specificed, proceed with offset
	// following the last read). Some types of streams may only support sequential reads.
	Offset int64 `json:"offset,omitempty"`

	// Size Maximum number of bytes to read (left upon the agent discretion if not specified).
	Size int64 `json:"size,omitempty"`
}

// IOReadResult type
type IOReadResult struct {
	// Base64Encoded Set if the data is base64-encoded
	Base64Encoded bool `json:"base64Encoded,omitempty"`

	// Data Data that were read.
	Data string `json:"data"`

	// EOF Set if the end-of-file condition occured while reading.
	EOF bool `json:"eof"`
}

// Call of the command, sessionID is optional.
func (m IORead) Call(c *Call) (*IOReadResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "IORead", m)
	if err != nil {
		return nil, err
	}

	var res IOReadResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IOResolveBlob Return UUID of Blob object specified by a remote object id.
type IOResolveBlob struct {
	// ObjectID Object id of a Blob object wrapper.
	ObjectID *RuntimeRemoteObjectID `json:"objectId"`
}

// IOResolveBlobResult type
type IOResolveBlobResult struct {
	// UUID UUID of the specified Blob.
	UUID string `json:"uuid"`
}

// Call of the command, sessionID is optional.
func (m IOResolveBlob) Call(c *Call) (*IOResolveBlobResult, error) {
	bin, err := c.Client.Call(c.Context, c.SessionID, "IOResolveBlob", m)
	if err != nil {
		return nil, err
	}

	var res IOResolveBlobResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}
